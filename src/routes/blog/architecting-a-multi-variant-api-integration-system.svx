---
title: "Architecting a Multi-Variant API Integration System"
date: "2025-12-22"
---

<script>
	import CodeBlock from '$lib/components/code-block.svelte';

	const beforeCode = `// Completely separate implementations
class GuardianApi {
  private connection = null;
  private proxyUri = undefined;

  async connect(apiUrl, apiKeyName, apiKeyToken) {
    // Guardian-specific auth
    const response = await fetch(\`\${apiUrl}/v1/auth\`, {
      method: 'POST',
      body: JSON.stringify({ key_name: apiKeyName })
    });
    // Guardian-specific response handling
  }
}

class VantageApi {
  private connection = null;
  private proxyUri = undefined; // Duplicate!

  async connect(apiUrl, apiKeyName, apiKeyToken) {
    // Vantage-specific auth (copy-pasted with tweaks)
    const response = await fetch(\`\${apiUrl}/v2/auth\`, {
      method: 'POST',
      body: JSON.stringify({ key_name: apiKeyName })
    });
    // Vantage-specific response handling
  }
}
// ... 500+ more lines duplicated per API`;

	const afterCode = `// Base class handles all shared logic
export abstract class BaseApi {
  protected connection: Connection | null = null;
  protected proxyUri: URL | undefined;

  protected getProxyAgent() {
    // Shared proxy logic
  }

  abstract connect(
    apiUrl: string,
    apiKeyName: string,
    apiKeyToken: string
  ): Promise<this>;
}

// API-specific classes only implement differences
export class GuardianApi extends BaseApi {
  async connect(apiUrl, apiKeyName, apiKeyToken) {
    const response = await fetch(\`\${apiUrl}/v1/auth\`, {
      dispatcher: this.getProxyAgent() // Inherited
    });
    this.connection = await response.json();
    return this;
  }
}

export class VantageApi extends BaseApi {
  async connect(apiUrl, apiKeyName, apiKeyToken) {
    const response = await fetch(\`\${apiUrl}/v2/auth\`, {
      dispatcher: this.getProxyAgent() // Same proxy logic
    });
    this.connection = { token: response.headers.get('Authorization') };
    return this;
  }
}`;

	const factoryCode = `// Factory creates jobs for any API type
function createInitializeJob(
  jobName: string,
  apiType: ApiType,
  getCurrentState: StateGetter
) {
  return addJobType(jobName, async ({ clientId }) => {
    try {
      await updateStatus(clientId, 'INITIALIZING');
      await updateIntegration(clientId, {
        state: await getCurrentState(clientId)
      });
      await updateStatus(clientId, 'READY');
    } catch (error) {
      Sentry.captureException(error, {
        tags: { api: apiType }
      });
      await updateStatus(clientId, 'FAILED');
    }
  });
}

// Create jobs for both APIs with one function
export const InitializeGuardianJob = createInitializeJob(
  'InitializeGuardian',
  'guardian',
  getGuardianState
);

export const InitializeVantageJob = createInitializeJob(
  'InitializeVantage',
  'vantage',
  getVantageState
);`;

	const routeCode = `// Single route for all API types
router.post(
  '/:clientId/:apiType/initialize',
  param('apiType').isIn(['guardian', 'vantage']),
  async (req, res) => {
    const { apiType } = req.params;

    const integration = await insertIntegration({
      client_id: req.params.clientId,
      status: 'UNINITIALIZED',
    });

    // Dispatch the right job based on API type
    const job = apiType === 'guardian'
      ? InitializeGuardianJob
      : InitializeVantageJob;

    await job.dispatch({ clientId: integration.client_id });
    res.json(integration);
  }
);`;
</script>

## The Challenge

Dispel needed to integrate with a third-party platform that had multiple API versions. The initial approach—building separate implementations for each variant—was creating unsustainable technical debt:

- Duplicate authentication logic across Guardian and Vantage APIs
- Separate job implementations for each API variant
- Copy-pasted error handling scattered across files
- Inconsistent database patterns—each integration did things differently
- Adding new API variants required 2-3 days of careful duplication
- Bug fixes had to be applied to multiple codebases

The team needed a system where adding new API variants was predictable, fast, and didn't require deep knowledge of our existing integrations.

## The Solution

I architected a unified integration system using base classes, factory patterns, and shared abstractions. The goal wasn't just reducing duplication—it was establishing a framework where any engineer could add new API variants confidently, following clear patterns rather than reverse-engineering existing code.

## From Duplicate Implementations to Shared Abstractions

The transformation was dramatic. Here's what changed:

### Before: Copy-Paste for Every Variant

<CodeBlock code={beforeCode} />

### After: Base Class + Specific Implementations

<CodeBlock code={afterCode} />

## Factory Pattern for Job Creation

Rather than duplicating job logic, I established factory functions that generate jobs with consistent error handling and monitoring:

<CodeBlock code={factoryCode} />

## Establishing Integration Patterns

### 60% Code Reduction

By extracting shared logic into base classes and factory functions, I reduced the integration codebase from ~1,500 lines per API to ~300 lines per API—with most of those 300 lines being API-specific business logic, not boilerplate.

### Team Impact

- **Democratized API integrations:** Any engineer can add new variants following established patterns
- **4-hour integration timeline:** New API variants ship in 4 hours instead of 2-3 days
- **Consistent error handling:** All integrations use the same monitoring and logging patterns
- **Single source of truth:** Bug fixes in BaseApi propagate to all integrations automatically

### Business Outcomes

- **Faster partnership velocity:** New integrations no longer block business development
- **Reduced maintenance burden:** Shared code means fewer places for bugs to hide
- **Better observability:** Consistent monitoring across all integrations
- **Enabled rapid scaling:** Added 3 new API variants in Q4 without expanding team size

## Unified Route Architecture

I established a single endpoint structure that handles all API variants through parameters, eliminating route duplication:

<CodeBlock code={routeCode} />

## Technical Architecture

- **Abstract base class** for shared connection and proxy logic
- **Factory functions** for consistent job creation across APIs
- **TypeScript inheritance** with abstract methods for type safety
- **Unified error handling** with Sentry integration
- **Parameterized routes** that handle multiple API types
- **Shared utility functions** for mapping and validation

## Impact

This architectural transformation changed how we approach third-party integrations at Dispel. By establishing clear patterns and shared abstractions, I enabled the team to add new integrations confidently and quickly, without requiring deep expertise in our existing codebase.

The best validation? An engineer who had been with us for 3 weeks added a new API variant in 4 hours—following the patterns I established without needing my direct involvement. That's the multiplier effect technical leadership should create: systems that scale beyond you.
