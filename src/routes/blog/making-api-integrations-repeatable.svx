---
title: "Making API Integrations Repeatable"
date: "2025-12-22"
---

<script>
	import CodeBlock from '$lib/components/code-block.svelte';

	const beforeCode = `// Completely separate implementations
class GuardianApi {
  private connection = null;
  private proxyUri = undefined;

  async connect(apiUrl, apiKeyName, apiKeyToken) {
    // Guardian-specific auth
    const response = await fetch(\`\${apiUrl}/v1/auth\`, {
      method: 'POST',
      body: JSON.stringify({ key_name: apiKeyName })
    });
    // Guardian-specific response handling
  }
}

class VantageApi {
  private connection = null;
  private proxyUri = undefined; // Duplicate!

  async connect(apiUrl, apiKeyName, apiKeyToken) {
    // Vantage-specific auth (copy-pasted with tweaks)
    const response = await fetch(\`\${apiUrl}/v2/auth\`, {
      method: 'POST',
      body: JSON.stringify({ key_name: apiKeyName })
    });
    // Vantage-specific response handling
  }
}
// ... 500+ more lines duplicated per API`;

	const afterCode = `// Base class handles all shared logic
export abstract class BaseApi {
  protected connection: Connection | null = null;
  protected proxyUri: URL | undefined;

  protected getProxyAgent() {
    // Shared proxy logic
  }

  abstract connect(
    apiUrl: string,
    apiKeyName: string,
    apiKeyToken: string
  ): Promise<this>;
}

// API-specific classes only implement differences
export class GuardianApi extends BaseApi {
  async connect(apiUrl, apiKeyName, apiKeyToken) {
    const response = await fetch(\`\${apiUrl}/v1/auth\`, {
      dispatcher: this.getProxyAgent() // Inherited
    });
    this.connection = await response.json();
    return this;
  }
}

export class VantageApi extends BaseApi {
  async connect(apiUrl, apiKeyName, apiKeyToken) {
    const response = await fetch(\`\${apiUrl}/v2/auth\`, {
      dispatcher: this.getProxyAgent() // Same proxy logic
    });
    this.connection = { token: response.headers.get('Authorization') };
    return this;
  }
}`;

	const factoryCode = `// Factory creates jobs for any API type
function createInitializeJob(
  jobName: string,
  apiType: ApiType,
  getCurrentState: StateGetter
) {
  return addJobType(jobName, async ({ clientId }) => {
    try {
      await updateStatus(clientId, 'INITIALIZING');
      await updateIntegration(clientId, {
        state: await getCurrentState(clientId)
      });
      await updateStatus(clientId, 'READY');
    } catch (error) {
      Sentry.captureException(error, {
        tags: { api: apiType }
      });
      await updateStatus(clientId, 'FAILED');
    }
  });
}

// Create jobs for both APIs with one function
export const InitializeGuardianJob = createInitializeJob(
  'InitializeGuardian',
  'guardian',
  getGuardianState
);

export const InitializeVantageJob = createInitializeJob(
  'InitializeVantage',
  'vantage',
  getVantageState
);`;

	const routeCode = `// Single route for all API types
router.post(
  '/:clientId/:apiType/initialize',
  param('apiType').isIn(['guardian', 'vantage']),
  async (req, res) => {
    const { apiType } = req.params;

    const integration = await insertIntegration({
      client_id: req.params.clientId,
      status: 'UNINITIALIZED',
    });

    // Dispatch the right job based on API type
    const job = apiType === 'guardian'
      ? InitializeGuardianJob
      : InitializeVantageJob;

    await job.dispatch({ clientId: integration.client_id });
    res.json(integration);
  }
);`;
</script>

## The Challenge

The platform needed to integrate with a third-party system that had multiple API versions. Without repeatable patterns, each integration was built from scratch—duplicate authentication logic, copy-pasted error handling, and inconsistent implementations. Adding new API variants required 2-3 days of custom work, and bug fixes had to be applied to multiple codebases.

## The Solution

I established a repeatable integration framework using base classes, factory patterns, and shared abstractions. The goal: make API integrations repeatable so any engineer could add new variants by following standardized patterns instead of rebuilding from scratch.

## From Custom Implementations to Repeatable Patterns

The transformation was dramatic. Here's what changed:

<CodeBlock code={beforeCode} />

<CodeBlock code={afterCode} />

## Repeatable Job Creation

I established factory functions that generate jobs with consistent error handling and monitoring, making job creation repeatable across all API variants:

<CodeBlock code={factoryCode} />

## Standardized Route Architecture

I established a single endpoint structure that handles all API variants through parameters, standardizing the integration pattern:

<CodeBlock code={routeCode} />

## Impact

**Repeatable integrations:** New API variants ship in 4 hours instead of 2-3 days of custom work. Engineers follow repeatable patterns without needing deep integration expertise. Bug fixes in BaseApi propagate to all integrations automatically, and standardized error handling ensures uniform monitoring across all variants.

**Scalable framework:** Reduced codebase from ~1,500 lines per API to ~300 lines per API. Added 3 new API variants in Q4 without expanding team size. The repeatable framework reduced maintenance burden and improved observability.

An engineer who had been with the team for 3 weeks added a new API variant in 4 hours—following the repeatable patterns without needing direct guidance.
