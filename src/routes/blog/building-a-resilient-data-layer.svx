---
title: "Slaying the Dragon: How I Eliminated Data-Layer P1 Incidents"
date: "2025-11-18"
---

<script>
	import Mermaid from '$lib/components/mermaid.svelte';

	const beforeDiagram = `graph TD
A[User Visits Dashboard] --> B[Component Mounts]
B --> C[useEffect Fires]
C --> D[Fetch Devices]
C --> E[Fetch Alerts]
C --> F[Fetch Users]
D --> G{Success?}
E --> H{Success?}
F --> I{Success?}
G -->|Yes| J[Render]
G -->|No| K[ðŸ’¥ Page Unusable]
H -->|Yes| J
H -->|No| K
I -->|Yes| J
I -->|No| K
K --> L[P1 Incident]

style K fill:#dc2626,stroke:#991b1b,stroke-width:3px
style L fill:#7f1d1d,stroke:#991b1b,stroke-width:2px`;

	const afterDiagram = `graph TD
A[User Visits Dashboard] --> B[Page Loads]
B --> C[Section: Devices]
B --> D[Section: Alerts]
B --> E[Section: Users]

C --> C1{Cached?}
C1 -->|Yes| C2[âœ“ Instant]
C1 -->|No| C3[Show Skeleton]
C3 --> C4{API Call}
C4 -->|Success| C5[âœ“ Render]
C4 -->|Fail| C6[Error + Retry]

D --> D1{Cached?}
D1 -->|Yes| D2[âœ“ Instant]
D1 -->|No| D3[Show Skeleton]
D3 --> D4{API Call}
D4 -->|Success| D5[âœ“ Render]
D4 -->|Fail| D6[Error + Retry]

E --> E1{Cached?}
E1 -->|Yes| E2[âœ“ Instant]
E1 -->|No| E3[Show Skeleton]
E3 --> E4{API Call}
E4 -->|Success| E5[âœ“ Render]
E4 -->|Fail| E6[Error + Retry]

C6 --> C7[Page Still Works]
D6 --> C7
E6 --> C7

style C2 fill:#059669,stroke:#047857
style D2 fill:#059669,stroke:#047857
style E2 fill:#059669,stroke:#047857
style C5 fill:#10b981,stroke:#059669
style D5 fill:#10b981,stroke:#059669
style E5 fill:#10b981,stroke:#059669
style C6 fill:#f59e0b,stroke:#d97706
style D6 fill:#f59e0b,stroke:#d97706
style E6 fill:#f59e0b,stroke:#d97706
style C7 fill:#059669,stroke:#047857,stroke-width:3px`;
</script>

## The Dragon in the Codebase

During a front-end audit I led, I identified critical anti-patterns lurking in our brownfield codebase that were contributing to production instability. The data layer was a significant part of the problemâ€”when combined with backend issues, a failed API call made the platform unusable for an enterprise client, who reported a P1 incident.

I documented every issue in a comprehensive Jira epic and presented it to my manager, advocating for prioritization as part of our broader scalability and performance initiative. The audit revealed widespread data-fetching anti-patterns:

- useEffect fetches everywhereâ€”data refetched on every render
- Zero cachingâ€”same data requested multiple times per page
- No API contractsâ€”front-end had no idea what the backend returned
- No loading statesâ€”users stared at broken, unresponsive UIs
- One API failure broke entire pagesâ€”no boundaries, no recovery
- Engineers avoided complex pages because data fetching was so brittle

## The Solution

I architected a standardized data layer built on three foundations: an OpenAPI-generated client for type safety, React Query for declarative caching, and composable Suspense boundaries for resilient error recovery. The goal was making the platform resilient by defaultâ€”where failed requests couldn't cascade into P1 incidents.

## Architecture Comparison

The transformation from fragile to resilient:

### Before: Cascade of Failures

<Mermaid diagram={beforeDiagram} class="bg-zinc-900 border border-zinc-800 rounded-lg p-4" />

### After: Isolated, Resilient Boundaries

<Mermaid diagram={afterDiagram} class="bg-zinc-900 border border-zinc-800 rounded-lg p-4" />

## The Transformation

### Before: useEffect Anti-Patterns

```javascript
// Fetch on every render, no caching, no types
function Dashboard() {
  const [devices, setDevices] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/devices')
      .then(res => res.json())
      .then(data => setDevices(data)); // What shape is data?
  }, []); // Refetches on every render

  if (loading) return null; // No loading state

  // One failure = entire page unusable
  return <DeviceList devices={devices} />;
}
```

### After: Type-Safe, Cached, Resilient

```javascript
// OpenAPI-generated client with full type safety
import { api } from '@/lib/api-client';

function Dashboard() {
  return (
    <div className="space-y-4">
      <SuspenseSection
        fallback={<DeviceListSkeleton />}
        errorFallback={<ErrorRetry section="devices" />}
      >
        <DeviceSection />
      </SuspenseSection>
    </div>
  );
}

function DeviceSection() {
  const { data } = api.devices.list.useSuspenseQuery();
  return <DeviceList devices={data} />; // Fully typed
}
```

## Key Architectural Decisions

### 1. OpenAPI-Generated Client

Before: zero API contracts. Engineers guessed at response shapes and discovered mismatches in production. I established an OpenAPI-based generation pipeline for end-to-end type safety.

### 2. Composable Suspense Boundaries

Each UI section could fail, load, or succeed independently. One failed request no longer broke the entire page.

### 3. Automatic Caching with React Query

Eliminated redundant requests. Data cached by default, refetched intelligently. 70% reduction in API calls.

## Impact

### Team Impact

- **Zero P1 incidents** from failed API calls since implementation
- **70% reduction** in redundant API requests
- **Engineers ship confidently** without data-layer fear
- **TypeScript catches** API mismatches at compile time

### Business Outcomes

- **Platform reliability** improved dramatically
- **Customer satisfaction** increasedâ€”platform felt faster
- **Support tickets reduced**â€”users recovered from errors themselves
- **Feature velocity increased**â€”complex UIs no longer avoided

## The Foundation

This architectural transformation slayed the biggest dragon and fundamentally changed how UIs were built. By establishing resilient patterns by default, I enabled the team to build complex features confidently without worrying about data-fetching edge cases causing production incidents.

The best validation? Zero P1 incidents from failed API calls since implementation. Engineers now build multi-section dashboards without fear, knowing one failed request won't bring down the entire page. That's the kind of foundation technical leadership should establish: systems that make the right thing the easy thing.
